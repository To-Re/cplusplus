## 4.1 基础

**左值和右值**

大概理解：左值能放在 `=` 左边，右值只能放右边。

+ 赋值运算，得到结果是个左值
+ 取地址符，作用于左值对象，返回右值
+ 解引用符、下标运算符、递增递减运算，作用于左值对象返回左值



`decltype` 中表达式结果是左值，得到一个引用类型。

`decltype(*p)` 结果是 `int&`

`decltype(&p)` 结果是 `int**`



#### 求值顺序

明确规定运算对象求值顺序的符号有四种，`&&`、`||`、`?:`、`,` 

求值顺序和优先级、结合律无关。



## 4.2 算术运算符

c++11 新标准规定，整数除法向0取整

c++11 `a%b` 正负号与 `a` 相同



## 4.3 逻辑和关系运算符



## 4.4 赋值运算符

c++11 允许赋值语句右侧运算对象使用花括号初始化列表。



## 4.5 递增和递减运算符



## 4.6 成员访问运算符

`(*p).size()` == `p->size()` ， `*` 运算符优先级小于 `.` 所以必须加括号。

箭头返回结果是一个左值，点运算左值右值和成员所属对象相同。



## 4.7 条件运算符

`?:` 当两个表达式都是左值或者都能转换成同一种左值类型时，运算的结果是左值，否则运算结果是右值。



## 4.8 位运算

小整型会被提升至较大的整数类型，提升时高位加0即可。

符号位处理没有明确规定，建议位运算仅用于处理无符号类型。

左移在右侧插入0，右移如果是无符号左侧插入0，有符号视具体环境而定。



## 4.9 sizeof运算符

1、对引用类型执行 `sizeof` 运算得到被引用对象所占空间大小

2、对指针执行 `sizeof` 运算得到指针本身所占空间大小

3、对解引用指针执行 `sizeof` 运算得到指针指向对象所占空间大小，指针不需要有效

4、对数组执行 `sizeof` 运算得到数组中所有元素各执行一次 `sizeof` 运算结果求和

5、对 `string` 或 `vector` 执行 `sizeof` 得到该类型固定部分大小，不会计算对象中元素占用多少空间。



## 4.10 逗号运算符

从左往右执行，计算返回结果是右侧表达式的值，右侧对象是左值返回也是左值。



## 4.11 类型转换

算术转换：运算符运算对象转换成最宽类型。

整型提升：小整数类型转换成较大整数类型

无符号类型运算：`unsigned int` 和 `int` 转换为 `unsigned int` ，`int` 为负需要取模。如果有符号整型范围更大转换为有符号，有符号整型范围小转换为无符号。



#### 隐式转换

数组转换为指针，在 `decltype` 、`&` 、`sizeof` 、 `typeid` 等运算符中转换不会发生。

指针的转换：`nullptr` 能转换为任意指针类型，任意非常量指针转换为 `void *`，任意常量指针转换为 `const void *`

转换为 bool 类型：0为`false`，其他为 `true`

转换为常量：非常量能用常量引用其，也能用指针常量指向其。反之不行。



#### 显示转换

`cast-name<type>(expression)` type 转换目标，expression 需要转换的值，type是引用类型返回左值。

`cast-name` 存在四种，`static_cast` 、`dynamic_name` 、`const_cast` 、`reinterpret_cast` 。

`static_cast` ：任何具有明确定义的类型转换，只要不包含底层 `const` 。

`const_cast` ：只能改变运算对象的底层 `const` ，不能改变表达式类型。大概理解，可以去掉const，但是是否能写还是得看对象本身是否是个常量。

`reinterpret_cast` ：对运算对象位模式提供较低层次上的重新解释。大概理解，和 `static_cast` 相比修改了对对象的理解方式保留了原有比特位，重新解释每一位的功能，而不是类型的近似值转换。



#### 旧式的强制类型转换

`type(expr)` 或 `(type) expr` 会先判断能否用 `static_cast` 或 `const_cast` 合法转换，不能再通过`reinterpret_cast` 方法进行转换。



## 4.12 运算符优先级表



详见 p147